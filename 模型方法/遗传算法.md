---
created: 2025/11/20 14:18
updated: 2025/11/20 14:21
aliases:
  - Genetic Algorithm
  - GA
---
借鉴生物进化过程中的遗传、变异和选择机制，通过模拟种群的进化来寻找最优解。在工程管理中，可用于项目资源分配、工期优化等问题。例如，在资源有限的情况下，利用遗传算法确定各项任务的资源分配方案，以使项目总工期最短或成本最低。

遗传算法（Genetic Algorithm, GA）在工程管理中的典型用法是：  
把“进度、成本、资源、风险”等复杂组合优化问题**编码成染色体** → **让种群在约束下进化** → **几十代后自动给出近似最优方案**。  
相比人工试排或穷举，GA 能在巨大解空间里**快速摸到 Pareto 前沿**，且不怕问题非线性、不连续、不可导。

下面用“工程进度-成本-质量”三目标优化为例，5 步解释 。

---

### 1 染色体编码
一条染色体 = 一份可行施工方案。  
常用两种编码：

1. **任务优先序列编码**（解决资源约束项目调度 RCPSP）  
   染色体长度 = 任务数 n  
   基因 = 任务 ID 的排列，满足拓扑序。  
   例：  
   $$
   \text{Chrom}=[1,3,2,5,4,6]
   $$

2. **多参数级联编码**  
   同时优化“工序模式+开始时间+资源投入”：  
   $$
   \underbrace{[m_1,m_2,\dots,m_n]}_{\text{施工模式}} \Vert
   \underbrace{[s_1,s_2,\dots,s_n]}_{\text{开始时间}} \Vert
   \underbrace{[r_1,r_2,\dots,r_k]}_{\text{资源量}}
   $$

---

### 2 适应度函数（工程管理目标）
把管理 KPI 量化成可计算的标量或向量：

| 目标 | 数学表达 |
|---|---|
| 工期 | $f_1=\max(s_i+d_i)$ |
| 成本 | $f_2=\sum_{i=1}^n c_i(m_i,r_i)$ |
| 质量 | $f_3=\prod_{i=1}^n Q_i(m_i)$ （合格率连乘） |
| 资源峰值 | $f_4=\max_t \sum_{i\in \text{Active}(t)} r_{i}$ |

如需多目标，可直接取**加权线性组合**：
$$
F=\lambda_1 f_1 + \lambda_2 f_2 + \lambda_3 f_3 + \lambda_4 f_4
$$
或用 NSGA-II 得到 Pareto 前沿，让项目经理挑最满意解。

---

### 3 约束处理
工程硬约束写成**罚函数**加入适应度：

- 拓扑逻辑：$s_j \ge s_i+d_i$ 若 $i\prec j$  
  违反一次加巨大惩罚 $M$。
- 资源限量：$\sum_{i\in \text{Active}(t)} r_{ij}\le R_j^{\max}$  
  超限即罚 $P=\alpha \cdot (\text{超限值})^2$。

最终适应度  
$$
\text{Fit}= \begin{cases}
1/F & \text{若所有约束满足}\\[4pt]
1/(F+M+P) & \text{否则}
\end{cases}
$$

---

### 4 遗传算子
| 算子 | 工程含义 | 常用策略 |
|---|---|---|
| **选择** | 保留“短工期、低成本”方案 | 锦标赛规模 3 |
| **交叉**（OX、PMX） | 父代工序排列重组 | 交叉概率 0.8 |
| **变异** | 局部微调开始时间或施工模式 | 变异概率 0.1 |
| **精英保留** | 把史上最短工期方案直接搬进下一代 | 防止好解丢失 |

---

### 5 进化流程（Python 伪代码）
```python
pop = init_population(size=200)
for gen in range(500):
    offspring = []
    while len(offspring) < 200:
        p1, p2 = tournament_select(pop), tournament_select(pop)
        if random() < 0.8:
            c1, c2 = ox_crossover(p1, p2)
        else:
            c1, c2 = p1.copy(), p2.copy()
        mutate(c1, 0.1); mutate(c2, 0.1)
        offspring.extend([c1, c2])
    pop = elite_merge(pop, offspring)  # 保留前10 %精英
best = max(pop, key=lambda x: x.Fit)
```

---

### 6 实际工程收益
| 场景 | 传统做法 | GA 结果 |
|---|---|---|
| 30 道工序+3 种模式 | 人工排 2 周，工期 210 d | GA 1 h 给出 188 d，成本 ↓ 7 % |
| 多项目共享塔吊 | 经验峰值 8 台 | GA 优化后峰值 6 台，节省租赁费 15 % |
| 疫情扰动重排 | 需反复试算 | GA 自动把关键工序换模式，工期只延 3 % |

---

### 7 一句话总结
在工程管理里，**遗传算法 = 自动“育种”施工方案**：  
把进度、成本、资源写成染色体 → 让种群在约束下“适者生存” → 几百代后输出**近优可行计划**，省钱、省时间、还省项目经理的头发。